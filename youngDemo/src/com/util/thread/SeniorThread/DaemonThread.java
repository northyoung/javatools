package com.util.thread.SeniorThread;

/**
 * Created by young on 2016/11/7.
 *
 *  另外有几点需要注意：
 1、setDaemon(true)必须在调用线程的start（）方法之前设置，否则会跑出IllegalThreadStateException异常。
 2、在守护线程中产生的新线程也是守护线程。
 3、 不要认为所有的应用都可以分配给守护线程来进行服务，比如读写操作或者计算逻辑。
 */
public class DaemonThread {
}


/**
 线程可以阻塞于四种状态：

 1、当线程执行Thread.sleep（）时，它一直阻塞到指定的毫秒时间之后，或者阻塞被另一个线程打断；

 2、当线程碰到一条wait（）语句时，它会一直阻塞到接到通知（notify（））、被中断或经过了指定毫秒时间为止（若制定了超时值的话）

 3、线程阻塞与不同I/O的方式有多种。常见的一种方式是InputStream的read（）方法，该方法一直阻塞到从流中读取一个字节的数据为止，它可以无限阻塞，因此不能指定超时时间；

 4、线程也可以阻塞等待获取某个对象锁的排他性访问权限（即等待获得synchronized语句必须的锁时阻塞）。



 注意，并非所有的阻塞状态都是可中断的，以上阻塞状态的前两种可以被中断，后两种不会对中断做出反应