package com.util.thread.SeniorThread;

/**
 * Created by young on 2016/11/7.
 *
 * Volatile修饰的成员变量在每次被线程访问时，都强迫从共享内存中重读该成员变量的值。
 * 而且，当成员变量发生变化时，强迫线程将变化值回写到共享内存。这样在任何时刻，两
 * 个不同的线程总是看到某个成员变量的同一个值。
 * volatile是一种稍弱的同步机制，在访问volatile变量时不会执行加锁操作，也就不会执行
 * 线程阻塞，因此volatilei变量是一种比synchronized关键字更轻量级的同步机制。
 * 使用建议：在两个或者更多的线程需要访问的成员变量上使用volatile。当要访问的变量已
 * 在synchronized代码块中，或者为常量时，没必要使用volatile。
 */


/**
 *
 * 1、volatile变量是一种稍弱的同步机制在访问volatile变量时不会执行加锁操作，因此也就不会使执行线程阻塞，
 * 因此volatile变量是一种比synchronized关键字更轻量级的同步机制。
 2、从内存可见性的角度看，写入volatile变量相当于退出同步代码块，而读取volatile变量相当于进入同步代码块。
 3、在代码中如果过度依赖volatile变量来控制状态的可见性，通常会比使用锁的代码更脆弱，也更难以理解。仅当
 volatile变量能简化代码的实现以及对同步策略的验证时，才应该使用它。一般来说，用同步机制会更安全些。
 4、加锁机制（即同步机制）既可以确保可见性又可以确保原子性，而volatile变量只能确保可见性，原因是声明为
 volatile的简单变量如果当前值与该变量以前的值相关，那么volatile关键字不起作用，也就是说如下的表达式都不
 是原子操作：“count++”、“count = count+1”。

 * 当且仅当满足以下所有条件时，才应该使用volatile变量：
 1、对变量的写入操作不依赖变量的当前值，或者你能确保只有单个线程更新变量的值。
 2、该变量没有包含在具有其他变量的不变式中。
 *
 */
public class volatileThread {
}
